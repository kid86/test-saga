{"ast":null,"code":"/** @license React v16.5.2\n * simple-cache-provider.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n\n    var React = require('react');\n    /**\n     * Similar to invariant but only logs a warning if the condition is not met.\n     * This can be used to log issues in development environments in critical\n     * paths. Removing the logging code for production environments will keep the\n     * same logic and follow the same code paths.\n     */\n\n\n    var warningWithoutStack = function warningWithoutStack() {};\n\n    {\n      warningWithoutStack = function warningWithoutStack(condition, format) {\n        for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n          args[_key - 2] = arguments[_key];\n        }\n\n        if (format === undefined) {\n          throw new Error('`warningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');\n        }\n\n        if (args.length > 8) {\n          // Check before the condition to catch violations early.\n          throw new Error('warningWithoutStack() currently supports at most 8 arguments.');\n        }\n\n        if (condition) {\n          return;\n        }\n\n        if (typeof console !== 'undefined') {\n          var _args$map = args.map(function (item) {\n            return '' + item;\n          }),\n              a = _args$map[0],\n              b = _args$map[1],\n              c = _args$map[2],\n              d = _args$map[3],\n              e = _args$map[4],\n              f = _args$map[5],\n              g = _args$map[6],\n              h = _args$map[7];\n\n          var message = 'Warning: ' + format; // We intentionally don't use spread (or .apply) because it breaks IE9:\n          // https://github.com/facebook/react/issues/13610\n\n          switch (args.length) {\n            case 0:\n              console.error(message);\n              break;\n\n            case 1:\n              console.error(message, a);\n              break;\n\n            case 2:\n              console.error(message, a, b);\n              break;\n\n            case 3:\n              console.error(message, a, b, c);\n              break;\n\n            case 4:\n              console.error(message, a, b, c, d);\n              break;\n\n            case 5:\n              console.error(message, a, b, c, d, e);\n              break;\n\n            case 6:\n              console.error(message, a, b, c, d, e, f);\n              break;\n\n            case 7:\n              console.error(message, a, b, c, d, e, f, g);\n              break;\n\n            case 8:\n              console.error(message, a, b, c, d, e, f, g, h);\n              break;\n\n            default:\n              throw new Error('warningWithoutStack() currently supports at most 8 arguments.');\n          }\n        }\n\n        try {\n          // --- Welcome to debugging React ---\n          // This error was thrown as a convenience so that you can use this stack\n          // to find the callsite that caused this warning to fire.\n          var argIndex = 0;\n\n          var _message = 'Warning: ' + format.replace(/%s/g, function () {\n            return args[argIndex++];\n          });\n\n          throw new Error(_message);\n        } catch (x) {}\n      };\n    }\n    var warningWithoutStack$1 = warningWithoutStack;\n\n    function noop() {}\n\n    var Empty = 0;\n    var Pending = 1;\n    var Resolved = 2;\n    var Rejected = 3; // TODO: How do you express this type with Flow?\n\n    var CACHE_TYPE = void 0;\n    {\n      CACHE_TYPE = 0xcac4e;\n    }\n    var isCache = void 0;\n    {\n      isCache = function isCache(value) {\n        return value !== null && typeof value === 'object' && value.$$typeof === CACHE_TYPE;\n      };\n    } // TODO: Make this configurable per resource\n\n    var MAX_SIZE = 500;\n    var PAGE_SIZE = 50;\n\n    function createRecord(key) {\n      return {\n        status: Empty,\n        suspender: null,\n        key: key,\n        value: null,\n        error: null,\n        next: null,\n        previous: null\n      };\n    }\n\n    function createRecordCache() {\n      return {\n        map: new Map(),\n        head: null,\n        tail: null,\n        size: 0\n      };\n    }\n\n    function createCache(invalidator) {\n      var resourceMap = new Map();\n\n      function accessRecord(resourceType, key) {\n        {\n          !(typeof resourceType !== 'string' && typeof resourceType !== 'number') ? warningWithoutStack$1(false, 'Invalid resourceType: Expected a symbol, object, or function, but ' + 'instead received: %s. Strings and numbers are not permitted as ' + 'resource types.', resourceType) : void 0;\n        }\n        var recordCache = resourceMap.get(resourceType);\n\n        if (recordCache === undefined) {\n          recordCache = createRecordCache();\n          resourceMap.set(resourceType, recordCache);\n        }\n\n        var map = recordCache.map;\n        var record = map.get(key);\n\n        if (record === undefined) {\n          // This record does not already exist. Create a new one.\n          record = createRecord(key);\n          map.set(key, record);\n\n          if (recordCache.size >= MAX_SIZE) {\n            // The cache is already at maximum capacity. Remove PAGE_SIZE least\n            // recently used records.\n            // TODO: We assume the max capcity is greater than zero. Otherwise warn.\n            var _tail = recordCache.tail;\n\n            if (_tail !== null) {\n              var newTail = _tail;\n\n              for (var i = 0; i < PAGE_SIZE && newTail !== null; i++) {\n                recordCache.size -= 1;\n                map.delete(newTail.key);\n                newTail = newTail.previous;\n              }\n\n              recordCache.tail = newTail;\n\n              if (newTail !== null) {\n                newTail.next = null;\n              }\n            }\n          }\n        } else {\n          // This record is already cached. Remove it from its current position in\n          // the list. We'll add it to the front below.\n          var _previous = record.previous;\n          var _next = record.next;\n\n          if (_previous !== null) {\n            _previous.next = _next;\n          } else {\n            recordCache.head = _next;\n          }\n\n          if (_next !== null) {\n            _next.previous = _previous;\n          } else {\n            recordCache.tail = _previous;\n          }\n\n          recordCache.size -= 1;\n        } // Add the record to the front of the list.\n\n\n        var head = recordCache.head;\n        var newHead = record;\n        recordCache.head = newHead;\n        newHead.previous = null;\n        newHead.next = head;\n\n        if (head !== null) {\n          head.previous = newHead;\n        } else {\n          recordCache.tail = newHead;\n        }\n\n        recordCache.size += 1;\n        return newHead;\n      }\n\n      function load(emptyRecord, suspender) {\n        var pendingRecord = emptyRecord;\n        pendingRecord.status = Pending;\n        pendingRecord.suspender = suspender;\n        suspender.then(function (value) {\n          // Resource loaded successfully.\n          var resolvedRecord = pendingRecord;\n          resolvedRecord.status = Resolved;\n          resolvedRecord.suspender = null;\n          resolvedRecord.value = value;\n        }, function (error) {\n          // Resource failed to load. Stash the error for later so we can throw it\n          var rejectedRecord = pendingRecord;\n          rejectedRecord.status = Rejected;\n          rejectedRecord.suspender = null;\n          rejectedRecord.error = error;\n        });\n      }\n\n      var cache = {\n        invalidate: function invalidate() {\n          invalidator();\n        },\n        preload: function preload(resourceType, key, miss, missArg) {\n          var record = accessRecord(resourceType, key);\n\n          switch (record.status) {\n            case Empty:\n              // Warm the cache.\n              var _suspender = miss(missArg);\n\n              load(record, _suspender);\n              return;\n\n            case Pending:\n              // There's already a pending request.\n              return;\n\n            case Resolved:\n              // The resource is already in the cache.\n              return;\n\n            case Rejected:\n              // The request failed.\n              return;\n          }\n        },\n        read: function read(resourceType, key, miss, missArg) {\n          var record = accessRecord(resourceType, key);\n\n          switch (record.status) {\n            case Empty:\n              // Load the requested resource.\n              var _suspender2 = miss(missArg);\n\n              load(record, _suspender2);\n              throw _suspender2;\n\n            case Pending:\n              // There's already a pending request.\n              throw record.suspender;\n\n            case Resolved:\n              return record.value;\n\n            case Rejected:\n            default:\n              // The requested resource previously failed loading.\n              var _error = record.error;\n              throw _error;\n          }\n        }\n      };\n      {\n        cache.$$typeof = CACHE_TYPE;\n      }\n      return cache;\n    }\n\n    var warnIfNonPrimitiveKey = void 0;\n    {\n      warnIfNonPrimitiveKey = function warnIfNonPrimitiveKey(key, methodName) {\n        !(typeof key === 'string' || typeof key === 'number' || typeof key === 'boolean' || key === undefined || key === null) ? warningWithoutStack$1(false, '%s: Invalid key type. Expected a string, number, symbol, or boolean, ' + 'but instead received: %s' + '\\n\\nTo use non-primitive values as keys, you must pass a hash ' + 'function as the second argument to createResource().', methodName, key) : void 0;\n      };\n    } // These declarations are used to express function overloading. I wish there\n    // were a more elegant way to do this in the function definition itself.\n    // Primitive keys do not request a hash function.\n    // Non-primitive keys *do* require a hash function.\n    // eslint-disable-next-line no-redeclare\n    // eslint-disable-next-line no-redeclare\n\n    function createResource(loadResource, hash) {\n      var resource = {\n        read: function read(cache, key) {\n          {\n            !isCache(cache) ? warningWithoutStack$1(false, 'read(): The first argument must be a cache. Instead received: %s', cache) : void 0;\n          }\n\n          if (hash === undefined) {\n            {\n              warnIfNonPrimitiveKey(key, 'read');\n            }\n            return cache.read(resource, key, loadResource, key);\n          }\n\n          var hashedKey = hash(key);\n          return cache.read(resource, hashedKey, loadResource, key);\n        },\n        preload: function preload(cache, key) {\n          {\n            !isCache(cache) ? warningWithoutStack$1(false, 'preload(): The first argument must be a cache. Instead received: %s', cache) : void 0;\n          }\n\n          if (hash === undefined) {\n            {\n              warnIfNonPrimitiveKey(key, 'preload');\n            }\n            cache.preload(resource, key, loadResource, key);\n            return;\n          }\n\n          var hashedKey = hash(key);\n          cache.preload(resource, hashedKey, loadResource, key);\n        }\n      };\n      return resource;\n    } // Global cache has no eviction policy (except for, ya know, a browser refresh).\n\n\n    var globalCache = createCache(noop);\n    var SimpleCache = React.createContext(globalCache);\n    exports.createCache = createCache;\n    exports.createResource = createResource;\n    exports.SimpleCache = SimpleCache;\n  })();\n}","map":null,"metadata":{},"sourceType":"script"}